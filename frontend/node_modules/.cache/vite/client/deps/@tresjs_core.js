import {
  ACESFilmicToneMapping,
  ArrowHelper,
  BackSide,
  BufferAttribute,
  BufferGeometry,
  Camera,
  Clock,
  Color,
  DirectionalLightHelper,
  DoubleSide,
  Float32BufferAttribute,
  HemisphereLightHelper,
  Line,
  LineBasicMaterial,
  Mesh,
  MeshBasicMaterial,
  OrthographicCamera,
  PCFSoftShadowMap,
  PerspectiveCamera,
  PointLightHelper,
  Quaternion,
  REVISION,
  Raycaster,
  SRGBColorSpace,
  Scene,
  SpotLightHelper,
  TextureLoader,
  Vector2,
  Vector3,
  WebGLRenderer,
  three_module_exports
} from "./chunk-OSMUHC7Y.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@tresjs/core/dist/tres.js
import { ref as A, computed as L, watchEffect as B, onUnmounted as U, shallowRef as H, watch as ge, reactive as ve, readonly as Y, provide as K, inject as Be, createRenderer as je, defineComponent as ne, useSlots as He, getCurrentInstance as se, onMounted as Re, openBlock as Ie, createElementBlock as $e, normalizeClass as ze, unref as Ne, normalizeStyle as We, h as ie, Fragment as Ve } from "vue";

// node_modules/@vueuse/shared/index.mjs
import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from "vue-demi";
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger
  };
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var notNullish = (val) => val != null;
var toString = Object.prototype.toString;
var isObject = (val) => toString.call(val) === "[object Object]";
var noop = () => {
};
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration);
    });
  };
  return filter;
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function objectPick(obj, keys2, omitUndefined = false) {
  return keys2.reduce((n, k2) => {
    if (k2 in obj) {
      if (!omitUndefined || obj[k2] !== void 0)
        n[k2] = obj[k2];
    }
    return n;
  }, {});
}
function getLifeCycleTarget(target) {
  return target || getCurrentInstance();
}
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(
    debounceFilter(ms, options),
    fn
  );
}
function refDebounced(value, ms = 200, options = {}) {
  const debounced = ref(value.value);
  const updater = useDebounceFn(() => {
    debounced.value = value.value;
  }, ms, options);
  watch(value, () => updater());
  return debounced;
}
function toRefs(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function tryOnMounted(fn, sync = true, target) {
  const instance = getLifeCycleTarget();
  if (instance)
    onMounted(fn, target);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useIntervalFn(cb, interval = 1e3, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  let timer = null;
  const isActive = ref(false);
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    isActive.value = false;
    clean();
  }
  function resume() {
    const intervalValue = toValue(interval);
    if (intervalValue <= 0)
      return;
    isActive.value = true;
    if (immediateCallback)
      cb();
    clean();
    timer = setInterval(cb, intervalValue);
  }
  if (immediate && isClient)
    resume();
  if (isRef(interval) || typeof interval === "function") {
    const stopWatch = watch(interval, () => {
      if (isActive.value && isClient)
        resume();
    });
    tryOnScopeDispose(stopWatch);
  }
  tryOnScopeDispose(pause);
  return {
    isActive,
    pause,
    resume
  };
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef2, ref as ref2, shallowRef as shallowRef2, watchEffect as watchEffect2, computed as computed2, inject as inject2, isVue3 as isVue32, version as version2, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch as watch2, getCurrentInstance as getCurrentInstance2, customRef as customRef2, onUpdated, onMounted as onMounted2, isVue2 as isVue22, readonly as readonly2, nextTick as nextTick2, reactive as reactive2, markRaw, unref as unref2, getCurrentScope as getCurrentScope2, set, del, isReadonly, onBeforeUpdate } from "vue-demi";
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch2(
    () => [unrefElement(target), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMounted() {
  const isMounted = ref2(false);
  const instance = getCurrentInstance2();
  if (instance) {
    onMounted2(() => {
      isMounted.value = true;
    }, isVue22 ? void 0 : instance);
  }
  return isMounted;
}
function useSupported(callback) {
  const isMounted = useMounted();
  return computed2(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => {
    const value = toValue(target);
    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);
    return new Set(items);
  });
  const stopWatch = watch2(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow
  } = options;
  const isActive = ref2(false);
  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit && delta < intervalLimit) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose(pause);
  return {
    isActive: readonly2(isActive),
    pause,
    resume
  };
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref2(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", handler);
    else
      mediaQuery.removeListener(handler);
  };
  const stopWatch = watchEffect2(() => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(toValue(query));
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", handler);
    else
      mediaQuery.addListener(handler);
    matches.value = mediaQuery.matches;
  });
  tryOnScopeDispose(() => {
    stopWatch();
    cleanup();
    mediaQuery = void 0;
  });
  return matches;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function useDevicePixelRatio(options = {}) {
  const {
    window: window2 = defaultWindow
  } = options;
  const pixelRatio = ref2(1);
  if (window2) {
    let observe2 = function() {
      pixelRatio.value = window2.devicePixelRatio;
      cleanup2();
      media = window2.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);
      media.addEventListener("change", observe2, { once: true });
    }, cleanup2 = function() {
      media == null ? void 0 : media.removeEventListener("change", observe2);
    };
    let media;
    observe2();
    tryOnScopeDispose(cleanup2);
  }
  return { pixelRatio };
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed2(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);
  const stopWatch = watch2(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els)
          _el && observer.observe(_el, observerOptions);
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop
  };
}
function useElementBounding(target, options = {}) {
  const {
    reset = true,
    windowResize = true,
    windowScroll = true,
    immediate = true
  } = options;
  const height = ref2(0);
  const bottom = ref2(0);
  const left = ref2(0);
  const right = ref2(0);
  const top = ref2(0);
  const width = ref2(0);
  const x = ref2(0);
  const y = ref2(0);
  function update() {
    const el = unrefElement(target);
    if (!el) {
      if (reset) {
        height.value = 0;
        bottom.value = 0;
        left.value = 0;
        right.value = 0;
        top.value = 0;
        width.value = 0;
        x.value = 0;
        y.value = 0;
      }
      return;
    }
    const rect = el.getBoundingClientRect();
    height.value = rect.height;
    bottom.value = rect.bottom;
    left.value = rect.left;
    right.value = rect.right;
    top.value = rect.top;
    width.value = rect.width;
    x.value = rect.x;
    y.value = rect.y;
  }
  useResizeObserver(target, update);
  watch2(() => unrefElement(target), (ele) => !ele && update());
  useMutationObserver(target, update, {
    attributeFilter: ["style", "class"]
  });
  if (windowScroll)
    useEventListener("scroll", update, { capture: true, passive: true });
  if (windowResize)
    useEventListener("resize", update, { passive: true });
  tryOnMounted(() => {
    if (immediate)
      update();
  });
  return {
    height,
    bottom,
    left,
    right,
    top,
    width,
    x,
    y,
    update
  };
}
function useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {
  const { window: window2 = defaultWindow, box = "content-box" } = options;
  const isSVG = computed2(() => {
    var _a, _b;
    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes("svg");
  });
  const width = ref2(initialSize.width);
  const height = ref2(initialSize.height);
  const { stop: stop1 } = useResizeObserver(
    target,
    ([entry]) => {
      const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
      if (window2 && isSVG.value) {
        const $elem = unrefElement(target);
        if ($elem) {
          const rect = $elem.getBoundingClientRect();
          width.value = rect.width;
          height.value = rect.height;
        }
      } else {
        if (boxSize) {
          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
        } else {
          width.value = entry.contentRect.width;
          height.value = entry.contentRect.height;
        }
      }
    },
    options
  );
  tryOnMounted(() => {
    const ele = unrefElement(target);
    if (ele) {
      width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
      height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
    }
  });
  const stop2 = watch2(
    () => unrefElement(target),
    (ele) => {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    }
  );
  function stop() {
    stop1();
    stop2();
  }
  return {
    width,
    height,
    stop
  };
}
function useFps(options) {
  var _a;
  const fps = ref2(0);
  if (typeof performance === "undefined")
    return fps;
  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;
  let last = performance.now();
  let ticks = 0;
  useRafFn(() => {
    ticks += 1;
    if (ticks >= every) {
      const now = performance.now();
      const diff = now - last;
      fps.value = Math.round(1e3 / (diff / ticks));
      last = now;
      ticks = 0;
    }
  });
  return fps;
}
function useMemory(options = {}) {
  const memory = ref2();
  const isSupported = useSupported(() => typeof performance !== "undefined" && "memory" in performance);
  if (isSupported.value) {
    const { interval = 1e3 } = options;
    useIntervalFn(() => {
      memory.value = performance.memory;
    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });
  }
  return { isSupported, memory };
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
function usePointer(options = {}) {
  const {
    target = defaultWindow
  } = options;
  const isInside = ref2(false);
  const state = ref2(options.initialValue || {});
  Object.assign(state.value, defaultState, state.value);
  const handler = (event) => {
    isInside.value = true;
    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))
      return;
    state.value = objectPick(event, keys, false);
  };
  if (target) {
    const listenerOptions = { passive: true };
    useEventListener(target, ["pointerdown", "pointermove", "pointerup"], handler, listenerOptions);
    useEventListener(target, "pointerleave", () => isInside.value = false, listenerOptions);
  }
  return {
    ...toRefs(state),
    isInside
  };
}
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);
function useWindowSize(options = {}) {
  const {
    window: window2 = defaultWindow,
    initialWidth = Number.POSITIVE_INFINITY,
    initialHeight = Number.POSITIVE_INFINITY,
    listenOrientation = true,
    includeScrollbar = true
  } = options;
  const width = ref2(initialWidth);
  const height = ref2(initialHeight);
  const update = () => {
    if (window2) {
      if (includeScrollbar) {
        width.value = window2.innerWidth;
        height.value = window2.innerHeight;
      } else {
        width.value = window2.document.documentElement.clientWidth;
        height.value = window2.document.documentElement.clientHeight;
      }
    }
  };
  update();
  tryOnMounted(update);
  useEventListener("resize", update, { passive: true });
  if (listenOrientation) {
    const matches = useMediaQuery("(orientation: portrait)");
    watch2(matches, () => update());
  }
  return { width, height };
}

// node_modules/@tresjs/core/dist/tres.js
var Oe = Object.defineProperty;
var De = (e, r, t) => r in e ? Oe(e, r, { enumerable: true, configurable: true, writable: true, value: t }) : e[r] = t;
var Q = (e, r, t) => (De(e, typeof r != "symbol" ? r + "" : r, t), t);
var bt = "@tresjs/core";
var Et = "module";
var Ct = "3.9.0";
var xt = "pnpm@8.15.6";
var Mt = "Declarative ThreeJS using Vue Components";
var St = "Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)";
var kt = "MIT";
var Pt = [
  "vue",
  "3d",
  "threejs",
  "three",
  "threejs-vue"
];
var Tt = false;
var At = {
  ".": {
    types: "./dist/index.d.ts",
    import: "./dist/tres.js",
    require: "./dist/tres.umd.cjs"
  },
  "./components": {
    types: "./dist/src/components/index.d.ts"
  },
  "./composables": {
    types: "./dist/src/composables/index.d.ts"
  },
  "./types": {
    types: "./dist/src/types/index.d.ts"
  },
  "./utils": {
    types: "./dist/src/utils/index.d.ts"
  },
  "./*": "./*"
};
var Lt = "./dist/tres.js";
var Ot = "./dist/tres.js";
var Dt = "./dist/index.d.ts";
var Bt = [
  "*.d.ts",
  "dist"
];
var jt = {
  access: "public"
};
var Ht = {
  dev: "cd playground && npm run dev",
  build: "vite build",
  playground: "cd playground && npm run dev",
  test: "vitest",
  "test:ci": "vitest run",
  "test:ui": "vitest --ui",
  release: "release-it",
  coverage: "vitest run --coverage",
  lint: "eslint .",
  "lint:fix": "eslint . --fix",
  "docs:dev": "vitepress dev docs",
  "docs:build": "vitepress build docs",
  "docs:serve": "vitepress serve docs",
  "docs:preview": "vitepress preview docs",
  "docs:contributors": "esno scripts/update-contributors.ts",
  prepare: "node .husky/install.mjs"
};
var Rt = {
  three: ">=0.133",
  vue: ">=3.3"
};
var It = {
  "@alvarosabu/utils": "^3.1.1",
  "@vue/devtools-api": "^6.6.1",
  "@vueuse/core": "^10.7.0"
};
var $t = {
  "@release-it/conventional-changelog": "^8.0.1",
  "@stackblitz/sdk": "^1.9.0",
  "@tresjs/cientos": "3.8.0",
  "@tresjs/eslint-config": "^1.0.0",
  "@tresjs/eslint-config-vue": "^0.2.1",
  "@types/three": "^0.163.0",
  "@typescript-eslint/eslint-plugin": "^7.7.1",
  "@typescript-eslint/parser": "^7.7.1",
  "@vitejs/plugin-vue": "^5.0.4",
  "@vitest/coverage-c8": "^0.33.0",
  "@vitest/ui": "^1.5.0",
  "@vue/test-utils": "^2.4.3",
  eslint: "^9.1.1",
  "eslint-plugin-vue": "^9.25.0",
  esno: "^4.0.0",
  gsap: "^3.12.3",
  husky: "^9.0.11",
  jsdom: "^24.0.0",
  kolorist: "^1.8.0",
  ohmyfetch: "^0.4.21",
  pathe: "^1.1.1",
  "release-it": "^17.2.0",
  "rollup-plugin-analyzer": "^4.0.0",
  "rollup-plugin-copy": "^3.5.0",
  "rollup-plugin-visualizer": "^5.11.0",
  three: "^0.163.0",
  unocss: "^0.59.4",
  unplugin: "^1.10.1",
  "unplugin-vue-components": "^0.26.0",
  vite: "^5.2.10",
  "vite-plugin-banner": "^0.7.1",
  "vite-plugin-dts": "3.9.0",
  "vite-plugin-inspect": "^0.8.4",
  "vite-plugin-require-transform": "^1.0.21",
  "vite-svg-loader": "^5.1.0",
  vitepress: "1.1.3",
  vitest: "^1.5.0",
  vue: "^3.4.24",
  "vue-demi": "^0.14.6"
};
var zt = {
  name: bt,
  type: Et,
  version: Ct,
  packageManager: xt,
  description: Mt,
  author: St,
  license: kt,
  keywords: Pt,
  sideEffects: Tt,
  exports: At,
  main: Lt,
  module: Ot,
  types: Dt,
  files: Bt,
  publishConfig: jt,
  scripts: Ht,
  peerDependencies: Rt,
  dependencies: It,
  devDependencies: $t
};
var Nt = ({ sizes: e, scene: r }) => {
  const t = A([]), o = L(
    () => t.value[0]
  ), s = (a) => {
    const l = a instanceof Camera ? a : t.value.find((m) => m.uuid === a);
    if (!l)
      return;
    const c = t.value.filter(({ uuid: m }) => m !== l.uuid);
    t.value = [l, ...c];
  }, i = (a, l = false) => {
    t.value.some(({ uuid: c }) => c === a.uuid) || (l ? s(a) : t.value.push(a));
  }, n = (a) => {
    t.value = t.value.filter(({ uuid: l }) => l !== a.uuid);
  };
  return B(() => {
    e.aspectRatio.value && t.value.forEach((a) => {
      a instanceof PerspectiveCamera && (a.aspect = e.aspectRatio.value), (a instanceof PerspectiveCamera || a instanceof OrthographicCamera) && a.updateProjectionMatrix();
    });
  }), r.userData.tres__registerCamera = i, r.userData.tres__deregisterCamera = n, U(() => {
    t.value = [];
  }), {
    camera: o,
    cameras: t,
    registerCamera: i,
    deregisterCamera: n,
    setCameraActive: s
  };
};
var _e = createEventHook();
var be = createEventHook();
var re = createEventHook();
var j = new Clock();
var V = 0;
var F = 0;
var { pause: Wt, resume: Vt, isActive: Ft } = useRafFn(
  () => {
    _e.trigger({ delta: V, elapsed: F, clock: j }), be.trigger({ delta: V, elapsed: F, clock: j }), re.trigger({ delta: V, elapsed: F, clock: j });
  },
  { immediate: false }
);
re.on(() => {
  V = j.getDelta(), F = j.getElapsedTime();
});
var G = () => ({
  onBeforeLoop: _e.on,
  onLoop: be.on,
  onAfterLoop: re.on,
  pause: Wt,
  resume: Vt,
  isActive: Ft
});
var Ir = true;
var I = "[TresJS ▲ ■ ●] ";
function P() {
  function e(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.error(...o);
  }
  function r(...o) {
    typeof o[0] == "string" ? o[0] = I + o[0] : o.unshift(I), console.warn(...o);
  }
  function t(o, s) {
  }
  return {
    logError: e,
    logWarning: r,
    logMessage: t
  };
}
function $r(e) {
  return typeof e == "number" ? [e, e, e] : e instanceof Vector3 ? [e.x, e.y, e.z] : e;
}
function Ut(e) {
  return e instanceof Color ? e : Array.isArray(e) ? new Color(...e) : new Color(e);
}
var Gt = class extends Mesh {
  constructor(...t) {
    super(...t);
    Q(this, "type", "HightlightMesh");
    Q(this, "createTime");
    this.createTime = Date.now();
  }
  onBeforeRender() {
    const o = (Date.now() - this.createTime) / 1e3, n = 1 + 0.07 * Math.sin(2.5 * o);
    this.scale.set(n, n, n);
  }
};
var Ee = (e, r) => {
  for (const t of Object.keys(r))
    r[t] instanceof Object && Object.assign(r[t], Ee(e[t], r[t]));
  return Object.assign(e || {}, r), e;
};
var Qt = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
var qt = Jt(Qt);
function ce(e) {
  return e && e.nodeType === 1;
}
function $(e) {
  return e.replace(/-([a-z])/g, (r, t) => t.toUpperCase());
}
function Jt(e, r) {
  const t = /* @__PURE__ */ Object.create(null), o = e.split(",");
  for (let s = 0; s < o.length; s++)
    t[o[s]] = true;
  return r ? (s) => !!t[s.toLowerCase()] : (s) => !!t[s];
}
var Yt = (e, r) => {
  const t = /* @__PURE__ */ new Set(), o = [];
  for (const s of e) {
    const i = r(s);
    t.has(i) || (t.add(i), o.push(s));
  }
  return o;
};
var de = (e, r) => {
  if (!r)
    return;
  const t = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  return t == null ? void 0 : t.reduce((o, s) => o && o[s], e);
};
var Kt = (e, r, t) => {
  const o = Array.isArray(r) ? r : r.match(/([^[.\]])+/g);
  o && o.reduce((s, i, n) => (s[i] === void 0 && (s[i] = {}), n === o.length - 1 && (s[i] = t), s[i]), e);
};
function Ce(e, r) {
  if (ce(e) && ce(r)) {
    const s = e.attributes, i = r.attributes;
    return s.length !== i.length ? false : Array.from(s).every(({ name: n, value: a }) => r.getAttribute(n) === a);
  }
  if (e === r)
    return true;
  if (e === null || typeof e != "object" || r === null || typeof r != "object")
    return false;
  const t = Object.keys(e), o = Object.keys(r);
  if (t.length !== o.length)
    return false;
  for (const s of t)
    if (!o.includes(s) || !Ce(e[s], r[s]))
      return false;
  return true;
}
function Xt(e, r) {
  if (!Array.isArray(e) || !Array.isArray(r) || e.length !== r.length)
    return false;
  for (let t = 0; t < e.length; t++)
    if (!Ce(e[t], r[t]))
      return false;
  return true;
}
var Zt = Array.isArray;
function er(e, r, t, o) {
  const s = (l) => {
    if (l.uuid === r)
      return l;
    for (const c of l.children) {
      const m = s(c);
      if (m)
        return m;
    }
  }, i = s(e);
  if (!i) {
    console.warn("Object with UUID not found in the scene.");
    return;
  }
  let n = i;
  for (let l = 0; l < t.length - 1; l++)
    if (n[t[l]] !== void 0)
      n = n[t[l]];
    else {
      console.warn(`Property path is not valid: ${t.join(".")}`);
      return;
    }
  const a = t[t.length - 1];
  n[a] !== void 0 ? n[a] = o : console.warn(`Property path is not valid: ${t.join(".")}`);
}
function tr(e) {
  const r = new MeshBasicMaterial({
    color: 11003607,
    // Highlight color, e.g., yellow
    transparent: true,
    opacity: 0.2,
    depthTest: false,
    // So the highlight is always visible
    side: DoubleSide
    // To e
  });
  return new Gt(e.geometry.clone(), r);
}
function xe(e) {
  var t;
  let r = e.value;
  return e.value && ((t = e.value) != null && t.isMesh) && (r = e.value.position), Array.isArray(e.value) && (r = new Vector3(...r)), r;
}
var rr = Number.parseInt(REVISION.replace("dev", ""));
var z = {
  realistic: {
    shadows: true,
    physicallyCorrectLights: true,
    outputColorSpace: SRGBColorSpace,
    toneMapping: ACESFilmicToneMapping,
    toneMappingExposure: 3,
    shadowMap: {
      enabled: true,
      type: PCFSoftShadowMap
    }
  }
};
function or({
  scene: e,
  canvas: r,
  options: t,
  disableRender: o,
  contextParts: { sizes: s, camera: i }
}) {
  const n = L(() => ({
    alpha: toValue(t.alpha),
    depth: toValue(t.depth),
    canvas: unrefElement(r),
    context: toValue(t.context),
    stencil: toValue(t.stencil),
    antialias: toValue(t.antialias) === void 0 ? true : toValue(t.antialias),
    precision: toValue(t.precision),
    powerPreference: toValue(t.powerPreference),
    premultipliedAlpha: toValue(t.premultipliedAlpha),
    preserveDrawingBuffer: toValue(t.preserveDrawingBuffer),
    logarithmicDepthBuffer: toValue(t.logarithmicDepthBuffer),
    failIfMajorPerformanceCaveat: toValue(t.failIfMajorPerformanceCaveat)
  })), a = H(new WebGLRenderer(n.value));
  ge(n, () => {
    a.value.dispose(), a.value = new WebGLRenderer(n.value);
  }), B(() => {
    a.value.setSize(s.width.value, s.height.value);
  });
  const { pixelRatio: l } = useDevicePixelRatio();
  B(() => {
    a.value.setPixelRatio(l.value);
  });
  const { logError: c } = P(), d = (() => {
    const p = new WebGLRenderer(), y = {
      shadowMap: {
        enabled: p.shadowMap.enabled,
        type: p.shadowMap.type
      },
      toneMapping: p.toneMapping,
      toneMappingExposure: p.toneMappingExposure,
      outputColorSpace: p.outputColorSpace
    };
    return p.dispose(), y;
  })();
  B(() => {
    const p = toValue(t.preset);
    p && (p in z || c(`Renderer Preset must be one of these: ${Object.keys(z).join(", ")}`), Ee(a.value, z[p]));
    const y = (C, x) => {
      const w = toValue(C), S = () => {
        if (p)
          return de(z[p], x);
      };
      if (w !== void 0)
        return w;
      const v = S();
      return v !== void 0 ? v : de(d, x);
    }, b = (C, x) => Kt(a.value, x, y(C, x));
    b(t.shadows, "shadowMap.enabled"), b(t.toneMapping, "toneMapping"), b(t.shadowMapType, "shadowMap.type"), rr < 150 && b(!t.useLegacyLights, "physicallyCorrectLights"), b(t.outputColorSpace, "outputColorSpace"), b(t.toneMappingExposure, "toneMappingExposure");
    const M = y(t.clearColor, "clearColor");
    M && a.value.setClearColor(
      M ? Ut(M) : new Color(0)
      // default clear color is not easily/efficiently retrievable from three
    );
  });
  const { pause: u, resume: f, onLoop: h2 } = G();
  return h2(() => {
    i.value && !toValue(o) && a.value.render(e, i.value);
  }), f(), U(() => {
    u(), a.value.dispose(), a.value.forceContextLoss();
  }), {
    renderer: a
  };
}
var fe = (e) => typeof e == "function";
var nr = (e) => !!e && e.constructor === Array;
function sr(e) {
  const r = { nodes: {}, materials: {} };
  return e && e.traverse((t) => {
    t.name && (r.nodes[t.name] = t), t.material && !r.materials[t.material.name] && (r.materials[t.material.name] = t.material);
  }), r;
}
async function zr(e, r, t, o, s) {
  const { logError: i } = P(), n = new e();
  s && s(n), t && t(n);
  const l = (Array.isArray(r) ? r : [r]).map(
    (c) => new Promise((m, d) => {
      n.load(
        c,
        (u) => {
          u.scene && Object.assign(u, sr(u.scene)), m(u);
        },
        o,
        (u) => d(i("[useLoader] - Failed to load resource", u))
      );
    })
  );
  return nr(r) ? await Promise.all(l) : await l[0];
}
async function Nr(e, r) {
  const t = new TextureLoader(r), o = (s) => new Promise((i, n) => {
    t.load(
      s,
      (a) => i(a),
      () => null,
      () => {
        n(new Error("[useTextures] - Failed to load texture"));
      }
    );
  });
  if (Zt(e)) {
    const s = await Promise.all(e.map((i) => o(i)));
    return e.length > 1 ? s : s[0];
  } else {
    const {
      map: s,
      displacementMap: i,
      normalMap: n,
      roughnessMap: a,
      metalnessMap: l,
      aoMap: c,
      alphaMap: m,
      matcap: d
    } = e;
    return {
      map: s ? await o(s) : null,
      displacementMap: i ? await o(i) : null,
      normalMap: n ? await o(n) : null,
      roughnessMap: a ? await o(a) : null,
      metalnessMap: l ? await o(l) : null,
      aoMap: c ? await o(c) : null,
      alphaMap: m ? await o(m) : null,
      matcap: d ? await o(d) : null
    };
  }
}
var ir = (e, { renderer: r, camera: t, raycaster: o }) => {
  const s = L(() => r.value.domElement), { x: i, y: n } = usePointer({ target: s }), { width: a, height: l, top: c, left: m } = useElementBounding(s), d = ({ x: v, y: _ }) => {
    if (s.value)
      return {
        x: (v - m.value) / a.value * 2 - 1,
        y: -((_ - c.value) / l.value) * 2 + 1
      };
  }, u = ({ x: v, y: _ }) => {
    if (t.value)
      return o.value.setFromCamera(new Vector2(v, _), t.value), o.value.intersectObjects(e.value, false);
  }, f = (v) => {
    const _ = d({
      x: (v == null ? void 0 : v.clientX) ?? i.value,
      y: (v == null ? void 0 : v.clientY) ?? n.value
    });
    return _ ? u(_) || [] : [];
  }, h2 = L(() => f()), p = createEventHook(), y = createEventHook(), b = (v, _) => {
    v.trigger({ event: _, intersects: f(_) });
  }, M = (v) => {
    b(y, v);
  };
  let C;
  const x = (v) => {
    var _;
    C = (_ = f(v)[0]) == null ? void 0 : _.object;
  }, w = (v) => {
    var _;
    v instanceof PointerEvent && C === ((_ = f(v)[0]) == null ? void 0 : _.object) && b(p, v);
  }, S = (v) => y.trigger({ event: v, intersects: [] });
  return s.value.addEventListener("pointerup", w), s.value.addEventListener("pointerdown", x), s.value.addEventListener("pointermove", M), s.value.addEventListener("pointerleave", S), U(() => {
    s != null && s.value && (s.value.removeEventListener("pointerup", w), s.value.removeEventListener("pointerdown", x), s.value.removeEventListener("pointermove", M), s.value.removeEventListener("pointerleave", S));
  }), {
    intersects: h2,
    onClick: (v) => p.on(v).off,
    onPointerMove: (v) => y.on(v).off
  };
};
function Wr() {
  const { logWarning: e } = P();
  function r(i, n, a) {
    let l = null;
    return i.traverse((c) => {
      c[n] === a && (l = c);
    }), l || e(`Child with ${n} '${a}' not found.`), l;
  }
  function t(i, n, a) {
    const l = [];
    return i.traverse((c) => {
      c[n].includes(a) && l.push(c);
    }), l.length || e(`Children with ${n} '${a}' not found.`), l;
  }
  function o(i, n) {
    return r(i, "name", n);
  }
  function s(i, n) {
    return t(i, "name", n);
  }
  return {
    seek: r,
    seekByName: o,
    seekAll: t,
    seekAllByName: s
  };
}
var ar = ({ scene: e, contextParts: r }) => {
  const t = ve({
    click: /* @__PURE__ */ new Map(),
    pointerMove: /* @__PURE__ */ new Map(),
    pointerEnter: /* @__PURE__ */ new Map(),
    pointerLeave: /* @__PURE__ */ new Map()
  }), o = A(/* @__PURE__ */ new Set()), s = (u) => {
    o.value.add(u);
  }, i = (u) => {
    o.value.delete(u);
  }, n = (u) => {
    Object.values(t).forEach((f) => f.delete(u)), i(u);
  }, a = (u) => {
    const { onClick: f, onPointerMove: h2, onPointerEnter: p, onPointerLeave: y } = u;
    f && t.click.set(u, f), h2 && t.pointerMove.set(u, h2), p && t.pointerEnter.set(u, p), y && t.pointerLeave.set(u, y);
  };
  e.userData.tres__registerAtPointerEventHandler = a, e.userData.tres__deregisterAtPointerEventHandler = n, e.userData.tres__registerBlockingObjectAtPointerEventHandler = s, e.userData.tres__deregisterBlockingObjectAtPointerEventHandler = i;
  const l = L(
    () => Yt(
      [
        ...Array.from(o.value),
        ...Object.values(t).map((u) => Array.from(u.keys())).flat()
      ],
      ({ uuid: u }) => u
    )
  ), { onClick: c, onPointerMove: m } = ir(l, r);
  c(({ intersects: u, event: f }) => {
    var h2;
    u.length && ((h2 = t.click.get(u[0].object)) == null || h2(u[0], f));
  });
  let d;
  return m(({ intersects: u, event: f }) => {
    var M, C, x, w;
    const h2 = (M = u == null ? void 0 : u[0]) == null ? void 0 : M.object, { pointerLeave: p, pointerEnter: y, pointerMove: b } = t;
    d && d !== h2 && ((C = p.get(d)) == null || C(d, f)), h2 && (d !== h2 && ((x = y.get(h2)) == null || x(u[0], f)), (w = b.get(h2)) == null || w(u[0], f)), d = h2 || null;
  }), {
    registerObject: a,
    deregisterObject: n
  };
};
function Me(e) {
  let r = 0;
  return e.traverse((t) => {
    if (t.isMesh && t.geometry) {
      const o = t.geometry, s = o.attributes.position.count * 3 * Float32Array.BYTES_PER_ELEMENT, i = o.index ? o.index.count * Uint32Array.BYTES_PER_ELEMENT : 0, n = o.attributes.normal ? o.attributes.normal.count * 3 * Float32Array.BYTES_PER_ELEMENT : 0, a = o.attributes.uv ? o.attributes.uv.count * 2 * Float32Array.BYTES_PER_ELEMENT : 0, l = s + i + n + a;
      r += l;
    }
  }), r;
}
function lr(e) {
  return (e / 1024).toFixed(2);
}
var Z = A({});
var oe = (e) => Object.assign(Z.value, e);
function ur(e, r, t = 10) {
  const o = toValue(e) ? useWindowSize() : useElementSize(L(() => toValue(r).parentElement)), s = Y(refDebounced(o.width, t)), i = Y(refDebounced(o.height, t)), n = L(() => s.value / i.value);
  return {
    height: i,
    width: s,
    aspectRatio: n
  };
}
function cr({
  scene: e,
  canvas: r,
  windowSize: t,
  disableRender: o,
  rendererOptions: s
}) {
  const i = ur(t, r), n = H(e), {
    camera: a,
    cameras: l,
    registerCamera: c,
    deregisterCamera: m,
    setCameraActive: d
  } = Nt({ sizes: i, scene: e }), { renderer: u } = or(
    {
      scene: e,
      canvas: r,
      options: s,
      contextParts: { sizes: i, camera: a },
      disableRender: o
    }
  ), f = {
    sizes: i,
    scene: n,
    camera: a,
    cameras: Y(l),
    renderer: u,
    raycaster: H(new Raycaster()),
    controls: A(null),
    perf: {
      maxFrames: 160,
      fps: {
        value: 0,
        accumulator: []
      },
      memory: {
        currentMem: 0,
        allocatedMem: 0,
        accumulator: []
      }
    },
    extend: oe,
    registerCamera: c,
    setCameraActive: d,
    deregisterCamera: m
  };
  K("useTres", f);
  const h2 = 100, p = useFps({ every: h2 }), { isSupported: y, memory: b } = useMemory({ interval: h2 }), M = 160;
  let C = performance.now();
  const x = ({ timestamp: _ }) => {
    f.scene.value && (f.perf.memory.allocatedMem = Me(f.scene.value)), _ - C >= h2 && (C = _, f.perf.fps.accumulator.push(p.value), f.perf.fps.accumulator.length > M && f.perf.fps.accumulator.shift(), f.perf.fps.value = p.value, y.value && b.value && (f.perf.memory.accumulator.push(b.value.usedJSHeapSize / 1024 / 1024), f.perf.memory.accumulator.length > M && f.perf.memory.accumulator.shift(), f.perf.memory.currentMem = f.perf.memory.accumulator.reduce((Ae, Le) => Ae + Le, 0) / f.perf.memory.accumulator.length));
  };
  let w = 0;
  const S = 1, { pause: v } = useRafFn(({ delta: _ }) => {
    window.__TRES__DEVTOOLS__ && (x({ timestamp: performance.now() }), w += _, w >= S && (window.__TRES__DEVTOOLS__.cb(f), w = 0));
  }, { immediate: true });
  return U(() => {
    v();
  }), f;
}
function dr() {
  const e = Be("useTres");
  if (!e)
    throw new Error("useTresContext must be used together with useTresContextProvider");
  return e;
}
var Vr = dr;
var g = null;
var { logError: pe } = P();
var J = [
  "onClick",
  "onPointerMove",
  "onPointerEnter",
  "onPointerLeave"
];
var fr = {
  createElement(e, r, t, o) {
    var n, a;
    if (o || (o = {}), o.args || (o.args = []), e === "template" || qt(e))
      return null;
    let s = e.replace("Tres", ""), i;
    if (e === "primitive") {
      (o == null ? void 0 : o.object) === void 0 && pe("Tres primitives need a prop 'object'");
      const l = o.object;
      s = l.type, i = Object.assign(l, { type: s, attach: o.attach, primitive: true });
    } else {
      const l = Z.value[s];
      l || pe(`${s} is not defined on the THREE namespace. Use extend to add it to the catalog.`), i = new l(...o.args);
    }
    return i.isCamera && (o != null && o.position || i.position.set(3, 3, 3), o != null && o.lookAt || i.lookAt(0, 0, 0)), (o == null ? void 0 : o.attach) === void 0 && (i.isMaterial ? i.attach = "material" : i.isBufferGeometry && (i.attach = "geometry")), i.isObject3D && ((n = o == null ? void 0 : o.material) != null && n.isMaterial && (i.userData.tres__materialViaProp = true), (a = o == null ? void 0 : o.geometry) != null && a.isBufferGeometry && (i.userData.tres__geometryViaProp = true)), i.userData = {
      ...i.userData,
      tres__name: s
    }, i;
  },
  insert(e, r) {
    var o, s, i, n;
    r && r.isScene && (g = r);
    const t = r || g;
    if (e != null && e.isObject3D) {
      if (e != null && e.isCamera) {
        if (!(g != null && g.userData.tres__registerCamera))
          throw new Error("could not find tres__registerCamera on scene's userData");
        (s = g == null ? void 0 : (o = g.userData).tres__registerCamera) == null || s.call(o, e);
      }
      if (e && J.some((a) => e[a])) {
        if (!(g != null && g.userData.tres__registerAtPointerEventHandler))
          throw new Error("could not find tres__registerAtPointerEventHandler on scene's userData");
        (n = g == null ? void 0 : (i = g.userData).tres__registerAtPointerEventHandler) == null || n.call(i, e);
      }
    }
    e != null && e.isObject3D && (t != null && t.isObject3D) ? (t.add(e), e.dispatchEvent({ type: "added" })) : e != null && e.isFog ? t.fog = e : typeof (e == null ? void 0 : e.attach) == "string" && (e.__previousAttach = e[t == null ? void 0 : t.attach], t && (t[e.attach] = e));
  },
  remove(e) {
    var r, t;
    if (e) {
      if (e.isObject3D) {
        const o = e, s = (c) => {
          var d, u;
          const m = c;
          c.userData.tres__materialViaProp || ((d = m.material) == null || d.dispose(), m.material = void 0), c.userData.tres__geometryViaProp || ((u = m.geometry) == null || u.dispose(), m.geometry = void 0);
        }, i = g == null ? void 0 : g.userData.tres__deregisterAtPointerEventHandler, n = g == null ? void 0 : g.userData.tres__deregisterBlockingObjectAtPointerEventHandler, a = (c) => {
          var m, d;
          if (!n)
            throw new Error("could not find tres__deregisterBlockingObjectAtPointerEventHandler on scene's userData");
          if ((d = g == null ? void 0 : (m = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || d.call(m, c), !i)
            throw new Error("could not find tres__deregisterAtPointerEventHandler on scene's userData");
          c && J.some((u) => c[u]) && (i == null || i(c));
        }, l = (c) => {
          const m = g == null ? void 0 : g.userData.tres__deregisterCamera;
          if (!m)
            throw new Error("could not find tres__deregisterCamera on scene's userData");
          c.isCamera && (m == null || m(c));
        };
        (r = e.removeFromParent) == null || r.call(e), o.traverse((c) => {
          s(c), l(c), a == null || a(c);
        }), s(o), l(o), a == null || a(o);
      }
      (t = e.dispose) == null || t.call(e);
    }
  },
  patchProp(e, r, t, o) {
    var s, i, n, a;
    if (e) {
      let l = e, c = r;
      if (e.isObject3D && c === "blocks-pointer-events") {
        o || o === "" ? (i = g == null ? void 0 : (s = g.userData).tres__registerBlockingObjectAtPointerEventHandler) == null || i.call(s, e) : (a = g == null ? void 0 : (n = g.userData).tres__deregisterBlockingObjectAtPointerEventHandler) == null || a.call(n, e);
        return;
      }
      let m = $(c), d = l == null ? void 0 : l[m];
      if (c === "args") {
        const f = e, h2 = t ?? [], p = o ?? [], y = e.userData.tres__name || e.type;
        y && h2.length && !Xt(h2, p) && (l = Object.assign(f, new Z.value[y](...o)));
        return;
      }
      if (l.type === "BufferGeometry") {
        if (c === "args")
          return;
        l.setAttribute(
          $(c),
          new BufferAttribute(...o)
        );
        return;
      }
      if (c.includes("-") && d === void 0) {
        const f = c.split("-");
        d = f.reduce((h2, p) => h2[$(p)], l), c = f.pop(), m = c.toLowerCase(), d != null && d.set || (l = f.reduce((h2, p) => h2[$(p)], l));
      }
      let u = o;
      if (u === "" && (u = true), fe(d)) {
        J.includes(r) || (Array.isArray(u) ? e[m](...u) : e[m](u));
        return;
      }
      !(d != null && d.set) && !fe(d) ? l[m] = u : d.constructor === u.constructor && (d != null && d.copy) ? d == null || d.copy(u) : Array.isArray(u) ? d.set(...u) : !d.isColor && d.setScalar ? d.setScalar(u) : d.set(u);
    }
  },
  parentNode(e) {
    return (e == null ? void 0 : e.parent) || null;
  },
  createText: () => void 0,
  createComment: () => void 0,
  setText: () => void 0,
  setElementText: () => void 0,
  nextSibling: () => void 0,
  querySelector: () => void 0,
  setScopeId: () => void 0,
  cloneNode: () => void 0,
  insertStaticContent: () => void 0
};
var { render: pr } = je(fr);
oe(three_module_exports);
function mr() {
  return Se().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Se() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
var gr = typeof Proxy == "function";
var vr = "devtools-plugin:setup";
var hr = "plugin:settings:set";
var O;
var ee;
function yr() {
  var e;
  return O !== void 0 || (typeof window < "u" && window.performance ? (O = true, ee = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (O = true, ee = globalThis.perf_hooks.performance) : O = false), O;
}
function wr() {
  return yr() ? ee.now() : Date.now();
}
var _r = class {
  constructor(r, t) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = r, this.hook = t;
    const o = {};
    if (r.settings)
      for (const n in r.settings) {
        const a = r.settings[n];
        o[n] = a.defaultValue;
      }
    const s = `__vue-devtools-plugin-settings__${r.id}`;
    let i = Object.assign({}, o);
    try {
      const n = localStorage.getItem(s), a = JSON.parse(n);
      Object.assign(i, a);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return i;
      },
      setSettings(n) {
        try {
          localStorage.setItem(s, JSON.stringify(n));
        } catch {
        }
        i = n;
      },
      now() {
        return wr();
      }
    }, t && t.on(hr, (n, a) => {
      n === this.plugin.id && this.fallbacks.setSettings(a);
    }), this.proxiedOn = new Proxy({}, {
      get: (n, a) => this.target ? this.target.on[a] : (...l) => {
        this.onQueue.push({
          method: a,
          args: l
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (n, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
        method: a,
        args: l,
        resolve: () => {
        }
      }), this.fallbacks[a](...l)) : (...l) => new Promise((c) => {
        this.targetQueue.push({
          method: a,
          args: l,
          resolve: c
        });
      })
    });
  }
  async setRealTarget(r) {
    this.target = r;
    for (const t of this.onQueue)
      this.target.on[t.method](...t.args);
    for (const t of this.targetQueue)
      t.resolve(await this.target[t.method](...t.args));
  }
};
function br(e, r) {
  const t = e, o = Se(), s = mr(), i = gr && t.enableEarlyProxy;
  if (s && (o.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
    s.emit(vr, e, r);
  else {
    const n = i ? new _r(t, s) : null;
    (o.__VUE_DEVTOOLS_PLUGINS__ = o.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: t,
      setupFn: r,
      proxy: n
    }), n && r(n.proxiedTarget);
  }
}
function Er(e, r) {
  const t = `▲ ■ ●${e}`;
  typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(t, r) : r === "error" ? console.error(t) : r === "warn" ? console.warn(t) : console.log(t);
}
var ke = (e) => {
  const r = {
    id: e.uuid,
    label: e.type,
    children: [],
    tags: []
  };
  e.name !== "" && r.tags.push({
    label: e.name,
    textColor: 5750629,
    backgroundColor: 15793395
  });
  const t = Me(e);
  return t > 0 && r.tags.push({
    label: `${lr(t)} KB`,
    textColor: 15707189,
    backgroundColor: 16775644,
    tooltip: "Memory usage"
  }), e.type.includes("Light") && (r.tags.push({
    label: `${e.intensity}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Intensity"
  }), r.tags.push({
    label: `#${e.color.getHexString()}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Color"
  })), e.type.includes("Camera") && (r.tags.push({
    label: `${e.fov}°`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Field of view"
  }), r.tags.push({
    label: `x: ${Math.round(e.position.x)} y: ${Math.round(e.position.y)} z: ${Math.round(e.position.z)}`,
    textColor: 9738662,
    backgroundColor: 16316922,
    tooltip: "Position"
  })), r;
};
function Pe(e, r) {
  e.children.forEach((t) => {
    if (t.type === "HightlightMesh")
      return;
    const o = ke(t);
    r.children.push(o), Pe(t, o);
  });
}
var Cr = [];
var D = "tres:inspector";
var xr = ve({
  sceneGraph: null
});
function Mr(e, r) {
  br(
    {
      id: "dev.esm.tres",
      label: "TresJS 🪐",
      logo: "https://raw.githubusercontent.com/Tresjs/tres/main/public/favicon.svg",
      packageName: "tresjs",
      homepage: "https://tresjs.org",
      componentStateTypes: Cr,
      app: e
    },
    (t) => {
      typeof t.now != "function" && Er(
        "You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."
      ), t.addInspector({
        id: D,
        label: "TresJS 🪐",
        icon: "account_tree",
        treeFilterPlaceholder: "Search instances"
      }), setInterval(() => {
        t.sendInspectorTree(D);
      }, 1e3), setInterval(() => {
        t.notifyComponentUpdate();
      }, 5e3), t.on.getInspectorTree((i) => {
        if (i.inspectorId === D) {
          const n = ke(r.scene.value);
          Pe(r.scene.value, n), xr.sceneGraph = n, i.rootNodes = [n];
        }
      });
      let o = null, s = null;
      t.on.getInspectorState((i) => {
        if (i.inspectorId === D) {
          const [n] = r.scene.value.getObjectsByProperty("uuid", i.nodeId);
          if (!n)
            return;
          if (s && o && o.parent && s.remove(o), n.isMesh) {
            const a = tr(n);
            n.add(a), o = a, s = n;
          }
          i.state = {
            object: [
              {
                key: "uuid",
                editable: true,
                value: n.uuid
              },
              {
                key: "name",
                editable: true,
                value: n.name
              },
              {
                key: "type",
                editable: true,
                value: n.type
              },
              {
                key: "position",
                editable: true,
                value: n.position
              },
              {
                key: "rotation",
                editable: true,
                value: n.rotation
              },
              {
                key: "scale",
                editable: true,
                value: n.scale
              },
              {
                key: "geometry",
                value: n.geometry
              },
              {
                key: "material",
                value: n.material
              },
              {
                key: "color",
                editable: true,
                value: n.color
              },
              {
                key: "intensity",
                editable: true,
                value: n.intensity
              },
              {
                key: "castShadow",
                editable: true,
                value: n.castShadow
              },
              {
                key: "receiveShadow",
                editable: true,
                value: n.receiveShadow
              },
              {
                key: "frustumCulled",
                editable: true,
                value: n.frustumCulled
              },
              {
                key: "matrixAutoUpdate",
                editable: true,
                value: n.matrixAutoUpdate
              },
              {
                key: "matrixWorldNeedsUpdate",
                editable: true,
                value: n.matrixWorldNeedsUpdate
              },
              {
                key: "matrixWorld",
                value: n.matrixWorld
              },
              {
                key: "visible",
                editable: true,
                value: n.visible
              }
            ]
          };
        }
      }), t.on.editInspectorState((i) => {
        i.inspectorId === D && er(r.scene.value, i.nodeId, i.path, i.state.value);
      });
    }
  );
}
var Sr = ["data-scene", "data-tres"];
var kr = ne({
  __name: "TresCanvas",
  props: {
    shadows: { type: Boolean, default: void 0 },
    clearColor: {},
    toneMapping: {},
    shadowMapType: {},
    useLegacyLights: { type: Boolean, default: void 0 },
    outputColorSpace: {},
    toneMappingExposure: {},
    camera: {},
    preset: {},
    windowSize: { type: Boolean, default: void 0 },
    disableRender: { type: Boolean, default: void 0 },
    context: {},
    precision: {},
    alpha: { type: Boolean, default: void 0 },
    premultipliedAlpha: { type: Boolean },
    antialias: { type: Boolean, default: void 0 },
    stencil: { type: Boolean, default: void 0 },
    preserveDrawingBuffer: { type: Boolean, default: void 0 },
    powerPreference: {},
    depth: { type: Boolean, default: void 0 },
    logarithmicDepthBuffer: { type: Boolean, default: void 0 },
    failIfMajorPerformanceCaveat: { type: Boolean, default: void 0 }
  },
  setup(e, { expose: r }) {
    var h2;
    const t = e, o = He(), { logWarning: s } = P(), i = A(), n = H(new Scene()), { resume: a } = G(), l = (h2 = se()) == null ? void 0 : h2.appContext.app, c = (p) => ne({
      setup() {
        var b;
        const y = (b = se()) == null ? void 0 : b.appContext;
        return y && (y.app = l), K("useTres", p), K("extend", oe), typeof window < "u" && Mr(y.app, p), () => ie(Ve, null, o != null && o.default ? o.default() : []);
      }
    }), m = (p) => {
      const y = c(p);
      pr(ie(y), n.value);
    }, d = (p, y = false) => {
      n.value.children = [], y && (p.renderer.value.dispose(), p.renderer.value.renderLists.dispose(), p.renderer.value.forceContextLoss()), m(p), a();
    }, u = L(() => t.disableRender), f = H(null);
    return r({ context: f, dispose: () => d(f.value, true) }), Re(() => {
      const p = i;
      f.value = cr({
        scene: n.value,
        canvas: p,
        windowSize: t.windowSize,
        disableRender: u,
        rendererOptions: t
      }), ar({ scene: n.value, contextParts: f.value });
      const { registerCamera: y, camera: b, cameras: M, deregisterCamera: C } = f.value;
      m(f.value);
      const x = () => {
        const w = new PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1e3
        );
        w.position.set(3, 3, 3), w.lookAt(0, 0, 0), y(w);
        const S = B(() => {
          M.value.length >= 2 && (w.removeFromParent(), C(w), S == null || S());
        });
      };
      ge(
        () => t.camera,
        (w, S) => {
          w && y(w), S && (S.removeFromParent(), C(S));
        },
        {
          immediate: true
        }
      ), b.value || (s(
        "No camera found. Creating a default perspective camera. To have full control over a camera, please add one to the scene."
      ), x());
    }), (p, y) => (Ie(), $e("canvas", {
      ref_key: "canvas",
      ref: i,
      "data-scene": n.value.uuid,
      class: ze(p.$attrs.class),
      "data-tres": `tresjs ${Ne(zt).version}`,
      style: We({
        display: "block",
        width: "100%",
        height: "100%",
        position: p.windowSize ? "fixed" : "relative",
        top: 0,
        left: 0,
        pointerEvents: "auto",
        touchAction: "none",
        ...p.$attrs.style
      })
    }, null, 14, Sr));
  }
});
var Pr = [
  "TresCanvas",
  "TresLeches",
  "TresScene"
];
var Tr = {
  template: {
    compilerOptions: {
      isCustomElement: (e) => e.startsWith("Tres") && !Pr.includes(e) || e === "primitive"
    }
  }
};
var Fr = Tr;
var Ur = {
  mounted: (e, r) => {
    if (r.arg) {
      console.log(`v-log:${r.arg}`, e[r.arg]);
      return;
    }
    console.log("v-log", e);
  }
};
var Te = class extends Line {
  constructor(r, t) {
    const o = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], s = new BufferGeometry();
    s.setAttribute("position", new Float32BufferAttribute(o, 3)), s.computeBoundingSphere();
    const i = new LineBasicMaterial({ fog: false });
    super(s, i), this.light = r, this.color = t, this.type = "RectAreaLightHelper";
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], a = new BufferGeometry();
    a.setAttribute("position", new Float32BufferAttribute(n, 3)), a.computeBoundingSphere(), this.add(new Mesh(a, new MeshBasicMaterial({ side: BackSide, fog: false })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const r = this.material.color, t = Math.max(r.r, r.g, r.b);
      t > 1 && r.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
};
var { logWarning: me } = P();
var N;
var T;
var Ar = {
  DirectionalLight: DirectionalLightHelper,
  PointLight: PointLightHelper,
  SpotLight: SpotLightHelper,
  HemisphereLight: HemisphereLightHelper,
  RectAreaLight: Te
};
var Gr = {
  mounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    N = Ar[e.type], e.parent.add(new N(e, 1, e.color.getHex()));
  },
  updated: (e) => {
    T = e.parent.children.find((r) => r instanceof N), !(T instanceof Te) && T.update();
  },
  unmounted: (e) => {
    if (!e.isLight) {
      me(`${e.type} is not a light`);
      return;
    }
    T = e.parent.children.find((r) => r instanceof N), T && T.dispose && T.dispose(), e.parent.remove(T);
  }
};
var { logWarning: Lr } = P();
var Qr = {
  updated: (e, r) => {
    const t = xe(r);
    if (!t) {
      Lr(`v-always-look-at: problem with binding value: ${r.value}`);
      return;
    }
    const { onLoop: o } = G();
    o(() => {
      e.lookAt(t);
    });
  }
};
var { logWarning: Or } = P();
var k = null;
var qr = {
  updated: (e, r) => {
    var s;
    const t = xe(r);
    if (!t) {
      Or(`v-distance-to: problem with binding value: ${r.value}`);
      return;
    }
    k && (k.dispose(), e.parent.remove(k));
    const o = t.clone().sub(e.position);
    o.normalize(), k = new ArrowHelper(o, e.position, e.position.distanceTo(t), 16776960), e.parent.add(k), console.table(
      [
        ["Distance:", e.position.distanceTo(t)],
        [`origin: ${e.name || e.type}`, `x:${e.position.x}, y:${e.position.y}, z:${(s = e.position) == null ? void 0 : s.z}`],
        [`Destiny: ${e.name || e.type}`, `x:${t.x}, y:${t.y}, z:${t == null ? void 0 : t.z}`]
      ]
    );
  },
  unmounted: (e) => {
    k == null || k.dispose(), e.parent.remove(k);
  }
};
var { logWarning: Dr } = P();
var Jr = {
  mounted: (e, r) => {
    if (e.isCamera) {
      Dr(`Rotate the ${e.type} is not a good idea`);
      return;
    }
    const t = r.value ?? 0.01, o = A(r.modifiers.x || r.arg === "x" ? 1 : 0), s = A(r.modifiers.y || r.arg === "y" ? 1 : 0), i = A(r.modifiers.z || r.arg === "z" ? 1 : 0);
    o.value + s.value + i.value === 0 && (o.value = 1, s.value = 1);
    const n = new Quaternion().setFromAxisAngle(new Vector3(o.value, s.value, i.value).normalize(), t), { onLoop: a } = G();
    a(() => {
      e.applyQuaternion(n);
    });
  }
};
var Yr = {
  install(e) {
    e.component("TresCanvas", kr);
  }
};
export {
  kr as TresCanvas,
  Z as catalogue,
  Yr as default,
  oe as extend,
  Ir as isProd,
  Ut as normalizeColor,
  $r as normalizeVectorFlexibleParam,
  Fr as templateCompilerOptions,
  sr as trasverseObjects,
  Nt as useCamera,
  zr as useLoader,
  P as useLogger,
  ar as usePointerEventHandler,
  ir as useRaycaster,
  G as useRenderLoop,
  or as useRenderer,
  Wr as useSeek,
  Nr as useTexture,
  Vr as useTres,
  dr as useTresContext,
  cr as useTresContextProvider,
  Qr as vAlwaysLookAt,
  qr as vDistanceTo,
  Gr as vLightHelper,
  Ur as vLog,
  Jr as vRotate
};
//# sourceMappingURL=@tresjs_core.js.map
